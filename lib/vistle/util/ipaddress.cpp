#include "ipaddress.h"

#ifdef _WIN32
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0600
#endif
#include <winsock2.h>
#include <ws2tcpip.h>
#include <iphlpapi.h>
#pragma comment(lib, "Iphlpapi.lib")
#else
#include <sys/socket.h>
#include <netinet/in.h>
#include <ifaddrs.h>
#include <arpa/inet.h>
#endif

#include <iostream>
#include <cassert>
#include <cstring>
#include <string>
#include <boost/asio.hpp>

namespace vistle {

std::vector<boost::asio::ip::address> getLocalAddresses()
{
    std::vector<boost::asio::ip::address> addresses;

#ifdef _WIN32
    // Windows: use GetAdaptersAddresses from IP Helper API
    ULONG family = AF_UNSPEC;
    ULONG flags = GAA_FLAG_SKIP_ANYCAST | GAA_FLAG_SKIP_MULTICAST | GAA_FLAG_SKIP_DNS_SERVER;
    ULONG outBufLen = 0;
    PIP_ADAPTER_ADDRESSES adapterAddrs = nullptr;
    DWORD ret = GetAdaptersAddresses(family, flags, NULL, adapterAddrs, &outBufLen);
    if (ret == ERROR_BUFFER_OVERFLOW) {
        adapterAddrs = (IP_ADAPTER_ADDRESSES *)malloc(outBufLen);
        if (!adapterAddrs) {
            std::cerr << "getLocalAddresses: out of memory\n";
            return addresses;
        }
        ret = GetAdaptersAddresses(family, flags, NULL, adapterAddrs, &outBufLen);
    }
    if (ret != NO_ERROR) {
        std::cerr << "getLocalAddresses: GetAdaptersAddresses failed: " << ret << std::endl;
        if (adapterAddrs)
            free(adapterAddrs);
        return addresses;
    }

    static const auto localhost4 = boost::asio::ip::make_address_v4("127.0.0.1");
    static const auto localhost6 = boost::asio::ip::make_address_v6("::1");

    for (PIP_ADAPTER_ADDRESSES adapter = adapterAddrs; adapter; adapter = adapter->Next) {
        if (adapter->OperStatus != IfOperStatusUp)
            continue;
        for (PIP_ADAPTER_UNICAST_ADDRESS ua = adapter->FirstUnicastAddress; ua; ua = ua->Next) {
            SOCKADDR *sa = ua->Address.lpSockaddr;
            if (!sa)
                continue;
            int fam = sa->sa_family;
            if (fam != AF_INET && fam != AF_INET6)
                continue;

            char host[NI_MAXHOST] = {0};
            int sa_len = (fam == AF_INET) ? sizeof(sockaddr_in) : sizeof(sockaddr_in6);
            if (getnameinfo(sa, sa_len, host, NI_MAXHOST, NULL, 0, NI_NUMERICHOST) != 0)
                continue;

            try {
                if (fam == AF_INET) {
                    auto addr = boost::asio::ip::make_address_v4(host);
                    if (addr == localhost4)
                        continue;
                    addresses.push_back(addr);
                } else { // AF_INET6
                    // skip link-local addresses containing a scope id like "%12"
                    if (strchr(host, '%'))
                        continue;
                    auto addr = boost::asio::ip::make_address_v6(host);
                    if (addr == localhost6)
                        continue;
                    addresses.push_back(addr);
                }
            } catch (const std::exception &e) {
                // skip malformed addresses
                (void)e;
            }
        }
    }

    if (adapterAddrs)
        free(adapterAddrs);

#else
    // POSIX: existing getifaddrs-based implementation
    struct ifaddrs *ifaddr = nullptr;
    if (getifaddrs(&ifaddr) == -1) {
        std::cerr << "getLocalAddresses: error in getifaddrs: " << strerror(errno) << std::endl;
        return addresses;
    }

    static const auto localhost4 = boost::asio::ip::make_address_v4("127.0.0.1");
    static const auto localhost6 = boost::asio::ip::make_address_v6("::1");

    for (struct ifaddrs *ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {
        if (ifa->ifa_addr == NULL)
            continue;

        int family = ifa->ifa_addr->sa_family;
        if (family != AF_INET && family != AF_INET6)
            continue;

        // Try to get numeric address
        char host[NI_MAXHOST];
        if (getnameinfo(ifa->ifa_addr, sizeof(struct sockaddr_in), host, NI_MAXHOST, NULL, 0, NI_NUMERICHOST) == 0) {
            switch (family) {
            case AF_INET: {
                auto addr = boost::asio::ip::make_address_v4(host);
                if (addr == localhost4)
                    continue;
                addresses.push_back(addr);
                break;
            }
            case AF_INET6: {
                // skip link-local addresses
                if (strchr(host, '%')) {
                    continue;
                }
                auto addr = boost::asio::ip::make_address_v6(host);
                if (addr == localhost6)
                    continue;
                addresses.push_back(addr);
                break;
            }
            }
        }
    }

    freeifaddrs(ifaddr);
#endif

    return addresses;
}

} // namespace vistle
